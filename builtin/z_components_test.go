// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

// Copyright (c) Roman Atachiants and contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

package builtin

import (
	"bytes"
	"reflect"
	"testing"

	"github.com/kelindar/ecs"
	"github.com/stretchr/testify/assert"
	"github.com/vmihailenco/msgpack"
)

func Test_PoolOfFloat32(t *testing.T) {
	arr := NewPoolOfFloat32()
	assert.NotNil(t, arr)
	assert.Equal(t, reflect.TypeOf(arr), arr.Type())

	entity1 := ecs.NewEntity()
	entity2 := ecs.NewEntity()

	arr.Add(entity1, 0)
	arr.Add(entity2, 0)

	{
		count := 0
		arr.View(func(_ *float32) {
			count++
		})
		assert.Equal(t, 2, count)
	}

	entity1.Delete()
	entity2.Delete()

	{
		count := 0
		arr.Update(func(_ *float32) {
			count++
		})
		assert.Equal(t, 0, count)
	}
}

func Test_CodecOfFloat32(t *testing.T) {
	original := NewPoolOfFloat32()
	decoded := NewPoolOfFloat32()

	// Encode the buffer
	var encoded bytes.Buffer
	err := msgpack.NewEncoder(&encoded).Encode(original)

	// Decode from the buffer
	dec := msgpack.NewDecoder(bytes.NewBuffer(encoded.Bytes()))
	err = dec.Decode(decoded)
	assert.NoError(t, err)
	assert.Equal(t, original, decoded)
}

// Copyright (c) Roman Atachiants and contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

func Test_PoolOfFloat64(t *testing.T) {
	arr := NewPoolOfFloat64()
	assert.NotNil(t, arr)
	assert.Equal(t, reflect.TypeOf(arr), arr.Type())

	entity1 := ecs.NewEntity()
	entity2 := ecs.NewEntity()

	arr.Add(entity1, 0)
	arr.Add(entity2, 0)

	{
		count := 0
		arr.View(func(_ *float64) {
			count++
		})
		assert.Equal(t, 2, count)
	}

	entity1.Delete()
	entity2.Delete()

	{
		count := 0
		arr.Update(func(_ *float64) {
			count++
		})
		assert.Equal(t, 0, count)
	}
}

func Test_CodecOfFloat64(t *testing.T) {
	original := NewPoolOfFloat64()
	decoded := NewPoolOfFloat64()

	// Encode the buffer
	var encoded bytes.Buffer
	err := msgpack.NewEncoder(&encoded).Encode(original)

	// Decode from the buffer
	dec := msgpack.NewDecoder(bytes.NewBuffer(encoded.Bytes()))
	err = dec.Decode(decoded)
	assert.NoError(t, err)
	assert.Equal(t, original, decoded)
}

// Copyright (c) Roman Atachiants and contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

func Test_PoolOfInt16(t *testing.T) {
	arr := NewPoolOfInt16()
	assert.NotNil(t, arr)
	assert.Equal(t, reflect.TypeOf(arr), arr.Type())

	entity1 := ecs.NewEntity()
	entity2 := ecs.NewEntity()

	arr.Add(entity1, 0)
	arr.Add(entity2, 0)

	{
		count := 0
		arr.View(func(_ *int16) {
			count++
		})
		assert.Equal(t, 2, count)
	}

	entity1.Delete()
	entity2.Delete()

	{
		count := 0
		arr.Update(func(_ *int16) {
			count++
		})
		assert.Equal(t, 0, count)
	}
}

func Test_CodecOfInt16(t *testing.T) {
	original := NewPoolOfInt16()
	decoded := NewPoolOfInt16()

	// Encode the buffer
	var encoded bytes.Buffer
	err := msgpack.NewEncoder(&encoded).Encode(original)

	// Decode from the buffer
	dec := msgpack.NewDecoder(bytes.NewBuffer(encoded.Bytes()))
	err = dec.Decode(decoded)
	assert.NoError(t, err)
	assert.Equal(t, original, decoded)
}

// Copyright (c) Roman Atachiants and contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

func Test_PoolOfInt32(t *testing.T) {
	arr := NewPoolOfInt32()
	assert.NotNil(t, arr)
	assert.Equal(t, reflect.TypeOf(arr), arr.Type())

	entity1 := ecs.NewEntity()
	entity2 := ecs.NewEntity()

	arr.Add(entity1, 0)
	arr.Add(entity2, 0)

	{
		count := 0
		arr.View(func(_ *int32) {
			count++
		})
		assert.Equal(t, 2, count)
	}

	entity1.Delete()
	entity2.Delete()

	{
		count := 0
		arr.Update(func(_ *int32) {
			count++
		})
		assert.Equal(t, 0, count)
	}
}

func Test_CodecOfInt32(t *testing.T) {
	original := NewPoolOfInt32()
	decoded := NewPoolOfInt32()

	// Encode the buffer
	var encoded bytes.Buffer
	err := msgpack.NewEncoder(&encoded).Encode(original)

	// Decode from the buffer
	dec := msgpack.NewDecoder(bytes.NewBuffer(encoded.Bytes()))
	err = dec.Decode(decoded)
	assert.NoError(t, err)
	assert.Equal(t, original, decoded)
}

// Copyright (c) Roman Atachiants and contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

func Test_PoolOfInt64(t *testing.T) {
	arr := NewPoolOfInt64()
	assert.NotNil(t, arr)
	assert.Equal(t, reflect.TypeOf(arr), arr.Type())

	entity1 := ecs.NewEntity()
	entity2 := ecs.NewEntity()

	arr.Add(entity1, 0)
	arr.Add(entity2, 0)

	{
		count := 0
		arr.View(func(_ *int64) {
			count++
		})
		assert.Equal(t, 2, count)
	}

	entity1.Delete()
	entity2.Delete()

	{
		count := 0
		arr.Update(func(_ *int64) {
			count++
		})
		assert.Equal(t, 0, count)
	}
}

func Test_CodecOfInt64(t *testing.T) {
	original := NewPoolOfInt64()
	decoded := NewPoolOfInt64()

	// Encode the buffer
	var encoded bytes.Buffer
	err := msgpack.NewEncoder(&encoded).Encode(original)

	// Decode from the buffer
	dec := msgpack.NewDecoder(bytes.NewBuffer(encoded.Bytes()))
	err = dec.Decode(decoded)
	assert.NoError(t, err)
	assert.Equal(t, original, decoded)
}

// Copyright (c) Roman Atachiants and contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

func Test_PoolOfUint16(t *testing.T) {
	arr := NewPoolOfUint16()
	assert.NotNil(t, arr)
	assert.Equal(t, reflect.TypeOf(arr), arr.Type())

	entity1 := ecs.NewEntity()
	entity2 := ecs.NewEntity()

	arr.Add(entity1, 0)
	arr.Add(entity2, 0)

	{
		count := 0
		arr.View(func(_ *uint16) {
			count++
		})
		assert.Equal(t, 2, count)
	}

	entity1.Delete()
	entity2.Delete()

	{
		count := 0
		arr.Update(func(_ *uint16) {
			count++
		})
		assert.Equal(t, 0, count)
	}
}

func Test_CodecOfUint16(t *testing.T) {
	original := NewPoolOfUint16()
	decoded := NewPoolOfUint16()

	// Encode the buffer
	var encoded bytes.Buffer
	err := msgpack.NewEncoder(&encoded).Encode(original)

	// Decode from the buffer
	dec := msgpack.NewDecoder(bytes.NewBuffer(encoded.Bytes()))
	err = dec.Decode(decoded)
	assert.NoError(t, err)
	assert.Equal(t, original, decoded)
}

// Copyright (c) Roman Atachiants and contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

func Test_PoolOfUint32(t *testing.T) {
	arr := NewPoolOfUint32()
	assert.NotNil(t, arr)
	assert.Equal(t, reflect.TypeOf(arr), arr.Type())

	entity1 := ecs.NewEntity()
	entity2 := ecs.NewEntity()

	arr.Add(entity1, 0)
	arr.Add(entity2, 0)

	{
		count := 0
		arr.View(func(_ *uint32) {
			count++
		})
		assert.Equal(t, 2, count)
	}

	entity1.Delete()
	entity2.Delete()

	{
		count := 0
		arr.Update(func(_ *uint32) {
			count++
		})
		assert.Equal(t, 0, count)
	}
}

func Test_CodecOfUint32(t *testing.T) {
	original := NewPoolOfUint32()
	decoded := NewPoolOfUint32()

	// Encode the buffer
	var encoded bytes.Buffer
	err := msgpack.NewEncoder(&encoded).Encode(original)

	// Decode from the buffer
	dec := msgpack.NewDecoder(bytes.NewBuffer(encoded.Bytes()))
	err = dec.Decode(decoded)
	assert.NoError(t, err)
	assert.Equal(t, original, decoded)
}

// Copyright (c) Roman Atachiants and contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

func Test_PoolOfUint64(t *testing.T) {
	arr := NewPoolOfUint64()
	assert.NotNil(t, arr)
	assert.Equal(t, reflect.TypeOf(arr), arr.Type())

	entity1 := ecs.NewEntity()
	entity2 := ecs.NewEntity()

	arr.Add(entity1, 0)
	arr.Add(entity2, 0)

	{
		count := 0
		arr.View(func(_ *uint64) {
			count++
		})
		assert.Equal(t, 2, count)
	}

	entity1.Delete()
	entity2.Delete()

	{
		count := 0
		arr.Update(func(_ *uint64) {
			count++
		})
		assert.Equal(t, 0, count)
	}
}

func Test_CodecOfUint64(t *testing.T) {
	original := NewPoolOfUint64()
	decoded := NewPoolOfUint64()

	// Encode the buffer
	var encoded bytes.Buffer
	err := msgpack.NewEncoder(&encoded).Encode(original)

	// Decode from the buffer
	dec := msgpack.NewDecoder(bytes.NewBuffer(encoded.Bytes()))
	err = dec.Decode(decoded)
	assert.NoError(t, err)
	assert.Equal(t, original, decoded)
}
