// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

// Copyright (c) Roman Atachiants and contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

package builtin

import (
	"bytes"
	"reflect"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/vmihailenco/msgpack"
)

func Test_ProviderOfFloat32(t *testing.T) {
	arr := NewProviderOfFloat32()
	assert.NotNil(t, arr)
	assert.Equal(t, reflect.TypeOf(pageOfFloat32{}.data).Elem(), arr.Type())

	index1 := arr.Add(float32(123))
	index2 := arr.Add(float32(123))

	{
		count := 0
		arr.View(func(_ *float32) {
			count++
		})
		assert.Equal(t, 2, count)
	}

	assert.Equal(t, float32(123), arr.ViewAt(index1))
	arr.UpdateAt(index2, func(v *float32) {
		*v = 888
	})
	assert.Equal(t, float32(888), arr.ViewAt(index2))

	arr.RemoveAt(index1)
	arr.RemoveAt(index2)

	{
		count := 0
		arr.Update(func(_ *float32) {
			count++
		})
		assert.Equal(t, 0, count)
	}
}

func Test_CodecOfFloat32(t *testing.T) {
	original := NewProviderOfFloat32()
	decoded := NewProviderOfFloat32()

	// Encode the buffer
	var encoded bytes.Buffer
	err := msgpack.NewEncoder(&encoded).Encode(original)

	// Decode from the buffer
	dec := msgpack.NewDecoder(bytes.NewBuffer(encoded.Bytes()))
	err = dec.Decode(decoded)
	assert.NoError(t, err)
	assert.Equal(t, original, decoded)
}

// Copyright (c) Roman Atachiants and contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

func Test_ProviderOfFloat64(t *testing.T) {
	arr := NewProviderOfFloat64()
	assert.NotNil(t, arr)
	assert.Equal(t, reflect.TypeOf(pageOfFloat64{}.data).Elem(), arr.Type())

	index1 := arr.Add(float64(123))
	index2 := arr.Add(float64(123))

	{
		count := 0
		arr.View(func(_ *float64) {
			count++
		})
		assert.Equal(t, 2, count)
	}

	assert.Equal(t, float64(123), arr.ViewAt(index1))
	arr.UpdateAt(index2, func(v *float64) {
		*v = 888
	})
	assert.Equal(t, float64(888), arr.ViewAt(index2))

	arr.RemoveAt(index1)
	arr.RemoveAt(index2)

	{
		count := 0
		arr.Update(func(_ *float64) {
			count++
		})
		assert.Equal(t, 0, count)
	}
}

func Test_CodecOfFloat64(t *testing.T) {
	original := NewProviderOfFloat64()
	decoded := NewProviderOfFloat64()

	// Encode the buffer
	var encoded bytes.Buffer
	err := msgpack.NewEncoder(&encoded).Encode(original)

	// Decode from the buffer
	dec := msgpack.NewDecoder(bytes.NewBuffer(encoded.Bytes()))
	err = dec.Decode(decoded)
	assert.NoError(t, err)
	assert.Equal(t, original, decoded)
}

// Copyright (c) Roman Atachiants and contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

func Test_ProviderOfInt16(t *testing.T) {
	arr := NewProviderOfInt16()
	assert.NotNil(t, arr)
	assert.Equal(t, reflect.TypeOf(pageOfInt16{}.data).Elem(), arr.Type())

	index1 := arr.Add(int16(123))
	index2 := arr.Add(int16(123))

	{
		count := 0
		arr.View(func(_ *int16) {
			count++
		})
		assert.Equal(t, 2, count)
	}

	assert.Equal(t, int16(123), arr.ViewAt(index1))
	arr.UpdateAt(index2, func(v *int16) {
		*v = 888
	})
	assert.Equal(t, int16(888), arr.ViewAt(index2))

	arr.RemoveAt(index1)
	arr.RemoveAt(index2)

	{
		count := 0
		arr.Update(func(_ *int16) {
			count++
		})
		assert.Equal(t, 0, count)
	}
}

func Test_CodecOfInt16(t *testing.T) {
	original := NewProviderOfInt16()
	decoded := NewProviderOfInt16()

	// Encode the buffer
	var encoded bytes.Buffer
	err := msgpack.NewEncoder(&encoded).Encode(original)

	// Decode from the buffer
	dec := msgpack.NewDecoder(bytes.NewBuffer(encoded.Bytes()))
	err = dec.Decode(decoded)
	assert.NoError(t, err)
	assert.Equal(t, original, decoded)
}

// Copyright (c) Roman Atachiants and contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

func Test_ProviderOfInt32(t *testing.T) {
	arr := NewProviderOfInt32()
	assert.NotNil(t, arr)
	assert.Equal(t, reflect.TypeOf(pageOfInt32{}.data).Elem(), arr.Type())

	index1 := arr.Add(int32(123))
	index2 := arr.Add(int32(123))

	{
		count := 0
		arr.View(func(_ *int32) {
			count++
		})
		assert.Equal(t, 2, count)
	}

	assert.Equal(t, int32(123), arr.ViewAt(index1))
	arr.UpdateAt(index2, func(v *int32) {
		*v = 888
	})
	assert.Equal(t, int32(888), arr.ViewAt(index2))

	arr.RemoveAt(index1)
	arr.RemoveAt(index2)

	{
		count := 0
		arr.Update(func(_ *int32) {
			count++
		})
		assert.Equal(t, 0, count)
	}
}

func Test_CodecOfInt32(t *testing.T) {
	original := NewProviderOfInt32()
	decoded := NewProviderOfInt32()

	// Encode the buffer
	var encoded bytes.Buffer
	err := msgpack.NewEncoder(&encoded).Encode(original)

	// Decode from the buffer
	dec := msgpack.NewDecoder(bytes.NewBuffer(encoded.Bytes()))
	err = dec.Decode(decoded)
	assert.NoError(t, err)
	assert.Equal(t, original, decoded)
}

// Copyright (c) Roman Atachiants and contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

func Test_ProviderOfInt64(t *testing.T) {
	arr := NewProviderOfInt64()
	assert.NotNil(t, arr)
	assert.Equal(t, reflect.TypeOf(pageOfInt64{}.data).Elem(), arr.Type())

	index1 := arr.Add(int64(123))
	index2 := arr.Add(int64(123))

	{
		count := 0
		arr.View(func(_ *int64) {
			count++
		})
		assert.Equal(t, 2, count)
	}

	assert.Equal(t, int64(123), arr.ViewAt(index1))
	arr.UpdateAt(index2, func(v *int64) {
		*v = 888
	})
	assert.Equal(t, int64(888), arr.ViewAt(index2))

	arr.RemoveAt(index1)
	arr.RemoveAt(index2)

	{
		count := 0
		arr.Update(func(_ *int64) {
			count++
		})
		assert.Equal(t, 0, count)
	}
}

func Test_CodecOfInt64(t *testing.T) {
	original := NewProviderOfInt64()
	decoded := NewProviderOfInt64()

	// Encode the buffer
	var encoded bytes.Buffer
	err := msgpack.NewEncoder(&encoded).Encode(original)

	// Decode from the buffer
	dec := msgpack.NewDecoder(bytes.NewBuffer(encoded.Bytes()))
	err = dec.Decode(decoded)
	assert.NoError(t, err)
	assert.Equal(t, original, decoded)
}

// Copyright (c) Roman Atachiants and contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

func Test_ProviderOfUint16(t *testing.T) {
	arr := NewProviderOfUint16()
	assert.NotNil(t, arr)
	assert.Equal(t, reflect.TypeOf(pageOfUint16{}.data).Elem(), arr.Type())

	index1 := arr.Add(uint16(123))
	index2 := arr.Add(uint16(123))

	{
		count := 0
		arr.View(func(_ *uint16) {
			count++
		})
		assert.Equal(t, 2, count)
	}

	assert.Equal(t, uint16(123), arr.ViewAt(index1))
	arr.UpdateAt(index2, func(v *uint16) {
		*v = 888
	})
	assert.Equal(t, uint16(888), arr.ViewAt(index2))

	arr.RemoveAt(index1)
	arr.RemoveAt(index2)

	{
		count := 0
		arr.Update(func(_ *uint16) {
			count++
		})
		assert.Equal(t, 0, count)
	}
}

func Test_CodecOfUint16(t *testing.T) {
	original := NewProviderOfUint16()
	decoded := NewProviderOfUint16()

	// Encode the buffer
	var encoded bytes.Buffer
	err := msgpack.NewEncoder(&encoded).Encode(original)

	// Decode from the buffer
	dec := msgpack.NewDecoder(bytes.NewBuffer(encoded.Bytes()))
	err = dec.Decode(decoded)
	assert.NoError(t, err)
	assert.Equal(t, original, decoded)
}

// Copyright (c) Roman Atachiants and contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

func Test_ProviderOfUint32(t *testing.T) {
	arr := NewProviderOfUint32()
	assert.NotNil(t, arr)
	assert.Equal(t, reflect.TypeOf(pageOfUint32{}.data).Elem(), arr.Type())

	index1 := arr.Add(uint32(123))
	index2 := arr.Add(uint32(123))

	{
		count := 0
		arr.View(func(_ *uint32) {
			count++
		})
		assert.Equal(t, 2, count)
	}

	assert.Equal(t, uint32(123), arr.ViewAt(index1))
	arr.UpdateAt(index2, func(v *uint32) {
		*v = 888
	})
	assert.Equal(t, uint32(888), arr.ViewAt(index2))

	arr.RemoveAt(index1)
	arr.RemoveAt(index2)

	{
		count := 0
		arr.Update(func(_ *uint32) {
			count++
		})
		assert.Equal(t, 0, count)
	}
}

func Test_CodecOfUint32(t *testing.T) {
	original := NewProviderOfUint32()
	decoded := NewProviderOfUint32()

	// Encode the buffer
	var encoded bytes.Buffer
	err := msgpack.NewEncoder(&encoded).Encode(original)

	// Decode from the buffer
	dec := msgpack.NewDecoder(bytes.NewBuffer(encoded.Bytes()))
	err = dec.Decode(decoded)
	assert.NoError(t, err)
	assert.Equal(t, original, decoded)
}

// Copyright (c) Roman Atachiants and contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

func Test_ProviderOfUint64(t *testing.T) {
	arr := NewProviderOfUint64()
	assert.NotNil(t, arr)
	assert.Equal(t, reflect.TypeOf(pageOfUint64{}.data).Elem(), arr.Type())

	index1 := arr.Add(uint64(123))
	index2 := arr.Add(uint64(123))

	{
		count := 0
		arr.View(func(_ *uint64) {
			count++
		})
		assert.Equal(t, 2, count)
	}

	assert.Equal(t, uint64(123), arr.ViewAt(index1))
	arr.UpdateAt(index2, func(v *uint64) {
		*v = 888
	})
	assert.Equal(t, uint64(888), arr.ViewAt(index2))

	arr.RemoveAt(index1)
	arr.RemoveAt(index2)

	{
		count := 0
		arr.Update(func(_ *uint64) {
			count++
		})
		assert.Equal(t, 0, count)
	}
}

func Test_CodecOfUint64(t *testing.T) {
	original := NewProviderOfUint64()
	decoded := NewProviderOfUint64()

	// Encode the buffer
	var encoded bytes.Buffer
	err := msgpack.NewEncoder(&encoded).Encode(original)

	// Decode from the buffer
	dec := msgpack.NewDecoder(bytes.NewBuffer(encoded.Bytes()))
	err = dec.Decode(decoded)
	assert.NoError(t, err)
	assert.Equal(t, original, decoded)
}
