// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package provider

import (
	"math"
	"reflect"
	"sync"

	"github.com/vmihailenco/msgpack"
)

// --------------------------- Component of Point ----------------------------

// TypeOfPoint returns the type of the component
var TypeOfPoint = reflect.TypeOf(new(Point)).Elem()

// ProviderOfPoint represents an array of components.
type ProviderOfPoint struct {
	sync.RWMutex
	typ  reflect.Type
	free []int
	page []pageOfPoint
}

// NewProviderOfPoint creates an array of components for the specific type.
func NewProviderOfPoint() *ProviderOfPoint {
	const cap = 128
	c := &ProviderOfPoint{
		free: make([]int, 0, cap),
		page: make([]pageOfPoint, 0, cap),
	}
	c.typ = reflect.TypeOf(pageOfPoint{}.data).Elem()
	return c
}

// Type returns the type of the component.
func (c *ProviderOfPoint) Type() reflect.Type {
	return c.typ
}

// Add adds a component to the array. Returns the index in the array which
// can be used to remove the component from the array.
func (c *ProviderOfPoint) Add(v interface{}) int {
	return c.AddPoint(v.(Point)) // Must be of correct type
}

// AddPoint adds a component to the array. Returns the index in the array which
// can be used to remove the component from the array.
func (c *ProviderOfPoint) AddPoint(v Point) int {
	c.Lock()
	defer c.Unlock()

	if len(c.free) == 0 {
		pageAt := len(c.page)
		c.page = append(c.page, pageOfPoint{})
		c.free = append(c.free, pageAt)
		offset := c.page[pageAt].Add(v)
		return (64 * pageAt) + offset
	}

	// find the free page and append
	last := len(c.free) - 1
	pageAt := c.free[last]
	offset := c.page[pageAt].Add(v)
	if c.page[pageAt].IsFull() {
		c.free = c.free[:last]
	}
	return (64 * pageAt) + offset
}

// View iterates over the array but only acquires a read lock. Make sure you do
// not mutate the state during this iteration as the pointer is given merely for
// performance reasons.
func (c *ProviderOfPoint) View(f func(*Point)) {
	c.RLock()
	defer c.RUnlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// Update ranges over the data in the slice and lets the user update it. This
// acquires a read-write lock and is safe to update concurrently.
func (c *ProviderOfPoint) Update(f func(*Point)) {
	c.Lock()
	defer c.Unlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// ViewAt returns a specific component located at the given index. Read lock
// is acquired in this operation, use it sparingly.
func (c *ProviderOfPoint) ViewAt(index int) Point {
	pageAt, offset := index/64, index%64
	c.RLock()
	defer c.RUnlock()
	return *(c.page[pageAt].At(offset))
}

// UpdateAt updates a component at a specific location. Write lock is acquired
// in this operation, use it sparingly.
func (c *ProviderOfPoint) UpdateAt(index int, f func(*Point)) {
	pageAt, offset := index/64, index%64
	c.Lock()
	f(c.page[pageAt].At(offset))
	c.Unlock()
}

// RemoveAt removes a component at a specific location. Write lock is acquired
// in this operation, use it sparingly.
func (c *ProviderOfPoint) RemoveAt(index int) {
	pageAt, offset := index/64, index%64
	c.Lock()
	defer c.Unlock()
	if c.page[pageAt].IsFull() {
		c.free = append(c.free, pageAt)
	}
	c.page[pageAt].Del(offset)
}

// EncodeMsgpack encodes the component in message pack format into the writer.
func (c *ProviderOfPoint) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.Encode(c.free); err == nil {
		err = enc.Encode(c.page)
	}
	return
}

// DecodeMsgpack decodes the page from the reader in message pack format.
func (c *ProviderOfPoint) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if err = dec.Decode(&c.free); err == nil {
		err = dec.Decode(&c.page)
	}
	return
}

// ---------------------------- Page of Point -----------------------------

// Page represents a page for a particular type.
type pageOfPoint struct {
	full uint64
	data [64]Point
}

// Add adds an element to the page and returns the offset.
func (p *pageOfPoint) Add(v Point) (index int) {
	if p.IsFull() {
		return -1
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) == 0 {
			p.full |= (1 << i)
			p.data[i] = v
			return i
		}
	}
	return -1
}

// Del deletes an element at an offset.
func (p *pageOfPoint) Del(index int) {
	p.full &= uint64(^(1 << index))
}

// IsFull checks whether the page is full or not.
func (p *pageOfPoint) IsFull() bool {
	return p.full == math.MaxUint64
}

// At returns a specific component located at the given index.
func (p *pageOfPoint) At(index int) *Point {
	if (p.full & (1 << index)) > 0 {
		return &p.data[index]
	}
	return nil
}

// Range iterates over the page.
func (p *pageOfPoint) Range(f func(*Point)) {
	if p.IsFull() {
		for i := 0; i < 64; i++ {
			f(&p.data[i])
		}
		return
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) > 0 {
			f(&p.data[i])
		}
	}
}

// Encode encodes the page in message pack format into the writer.
func (p *pageOfPoint) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.EncodeUint64(p.full); err == nil {
		err = enc.Encode(p.data)
	}
	return
}

// Decode decodes the page from the reader in message pack format.
func (p *pageOfPoint) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if p.full, err = dec.DecodeUint64(); err == nil {
		err = dec.Decode(&p.data)
	}
	return
}
