// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package component

import (
	"math"
	"reflect"
	"sync"

	"github.com/kelindar/ecs"
	"github.com/vmihailenco/msgpack"
)

// --------------------------- Component of string ----------------------------

// OfString represents an array of components.
type OfString struct {
	sync.RWMutex
	typ  relfect.Type
	free []int
	page []pageOfString
}

// ForString creates an array of components for the specific type.
func ForString() *OfString {
	const cap = 128
	c := &OfString{
		free: make([]int, 0, cap),
		page: make([]pageOfString, 0, cap),
	}
	c.typ = relfect.TypeOf(c)
	return c
}

// Type returns the type of the component.
func (c *OfString) Type() reflect.Type {
	return c.typ
}

// Add adds a component to the array. Returns the index in the array which
// can be used to remove the component from the array.
func (c *OfString) Add(entity *ecs.Entity, v string) {
	c.Lock()
	defer c.Unlock()

	if len(c.free) == 0 {
		pageAt := len(c.page)
		c.page = append(c.page, pageOfString{})
		c.free = append(c.free, pageAt)
		c.attach(entity, pageAt, c.page[pageAt].Add(v))
		return
	}

	// find the free page and append
	last := len(c.free) - 1
	pageAt := c.free[last]
	offset := c.page[pageAt].Add(v)
	if c.page[pageAt].IsFull() {
		c.free = c.free[:last]
	}
	c.attach(entity, pageAt, offset)
}

// attach attaches the remove function to the entity.
func (c *OfString) attach(entity *ecs.Entity, pageAt, offset int) {
	index := (64 * pageAt) + offset
	entity.Attach(func() {
		c.Lock()
		defer c.Unlock()
		pageAt, offset := index/64, index%64
		if c.page[pageAt].IsFull() {
			c.free = append(c.free, pageAt)
		}
		c.page[pageAt].Del(offset)
	})
}

// View iterates over the array but only acquires a read lock. Make sure you do
// not mutate the state during this iteration as the pointer is given merely for
// performance reasons.
func (c *OfString) View(f func(*string)) {
	c.RLock()
	defer c.RUnlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// Update ranges over the data in the slice and lets the user update it. This
// acquires a read-write lock and is safe to update concurrently.
func (c *OfString) Update(f func(*string)) {
	c.Lock()
	defer c.Unlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// EncodeMsgpack encodes the component in message pack format into the writer.
func (c *OfString) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.Encode(c.free); err == nil {
		err = enc.Encode(c.page)
	}
	return
}

// DecodeMsgpack decodes the page from the reader in message pack format.
func (c *OfString) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if err = dec.Decode(&c.free); err == nil {
		err = dec.Decode(&c.page)
	}
	return
}

// ---------------------------- Page of string -----------------------------

// Page represents a page for a particular type.
type pageOfString struct {
	full uint64
	data [64]string
}

// Add adds an element to the page and returns the offset.
func (p *pageOfString) Add(v string) (index int) {
	if p.IsFull() {
		return -1
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) == 0 {
			p.full |= (1 << i)
			p.data[i] = v
			return i
		}
	}
	return -1
}

// Del deletes an element at an offset.
func (p *pageOfString) Del(index int) {
	p.full &= uint64(^(1 << index))
}

// IsFull checks whether the page is full or not.
func (p *pageOfString) IsFull() bool {
	return p.full == math.MaxUint64
}

// Range iterates over the page.
func (p *pageOfString) Range(f func(*string)) {
	if p.IsFull() {
		for i := 0; i < 64; i++ {
			f(&p.data[i])
		}
		return
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) > 0 {
			f(&p.data[i])
		}
	}
}

// Encode encodes the page in message pack format into the writer.
func (p *pageOfString) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.EncodeUint64(p.full); err == nil {
		err = enc.Encode(p.data)
	}
	return
}

// Decode decodes the page from the reader in message pack format.
func (p *pageOfString) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if p.full, err = dec.DecodeUint64(); err == nil {
		err = dec.Decode(&p.data)
	}
	return
}

// --------------------------- Component of bool ----------------------------

// OfBool represents an array of components.
type OfBool struct {
	sync.RWMutex
	typ  relfect.Type
	free []int
	page []pageOfBool
}

// ForBool creates an array of components for the specific type.
func ForBool() *OfBool {
	const cap = 128
	c := &OfBool{
		free: make([]int, 0, cap),
		page: make([]pageOfBool, 0, cap),
	}
	c.typ = relfect.TypeOf(c)
	return c
}

// Type returns the type of the component.
func (c *OfBool) Type() reflect.Type {
	return c.typ
}

// Add adds a component to the array. Returns the index in the array which
// can be used to remove the component from the array.
func (c *OfBool) Add(entity *ecs.Entity, v bool) {
	c.Lock()
	defer c.Unlock()

	if len(c.free) == 0 {
		pageAt := len(c.page)
		c.page = append(c.page, pageOfBool{})
		c.free = append(c.free, pageAt)
		c.attach(entity, pageAt, c.page[pageAt].Add(v))
		return
	}

	// find the free page and append
	last := len(c.free) - 1
	pageAt := c.free[last]
	offset := c.page[pageAt].Add(v)
	if c.page[pageAt].IsFull() {
		c.free = c.free[:last]
	}
	c.attach(entity, pageAt, offset)
}

// attach attaches the remove function to the entity.
func (c *OfBool) attach(entity *ecs.Entity, pageAt, offset int) {
	index := (64 * pageAt) + offset
	entity.Attach(func() {
		c.Lock()
		defer c.Unlock()
		pageAt, offset := index/64, index%64
		if c.page[pageAt].IsFull() {
			c.free = append(c.free, pageAt)
		}
		c.page[pageAt].Del(offset)
	})
}

// View iterates over the array but only acquires a read lock. Make sure you do
// not mutate the state during this iteration as the pointer is given merely for
// performance reasons.
func (c *OfBool) View(f func(*bool)) {
	c.RLock()
	defer c.RUnlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// Update ranges over the data in the slice and lets the user update it. This
// acquires a read-write lock and is safe to update concurrently.
func (c *OfBool) Update(f func(*bool)) {
	c.Lock()
	defer c.Unlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// EncodeMsgpack encodes the component in message pack format into the writer.
func (c *OfBool) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.Encode(c.free); err == nil {
		err = enc.Encode(c.page)
	}
	return
}

// DecodeMsgpack decodes the page from the reader in message pack format.
func (c *OfBool) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if err = dec.Decode(&c.free); err == nil {
		err = dec.Decode(&c.page)
	}
	return
}

// ---------------------------- Page of bool -----------------------------

// Page represents a page for a particular type.
type pageOfBool struct {
	full uint64
	data [64]bool
}

// Add adds an element to the page and returns the offset.
func (p *pageOfBool) Add(v bool) (index int) {
	if p.IsFull() {
		return -1
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) == 0 {
			p.full |= (1 << i)
			p.data[i] = v
			return i
		}
	}
	return -1
}

// Del deletes an element at an offset.
func (p *pageOfBool) Del(index int) {
	p.full &= uint64(^(1 << index))
}

// IsFull checks whether the page is full or not.
func (p *pageOfBool) IsFull() bool {
	return p.full == math.MaxUint64
}

// Range iterates over the page.
func (p *pageOfBool) Range(f func(*bool)) {
	if p.IsFull() {
		for i := 0; i < 64; i++ {
			f(&p.data[i])
		}
		return
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) > 0 {
			f(&p.data[i])
		}
	}
}

// Encode encodes the page in message pack format into the writer.
func (p *pageOfBool) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.EncodeUint64(p.full); err == nil {
		err = enc.Encode(p.data)
	}
	return
}

// Decode decodes the page from the reader in message pack format.
func (p *pageOfBool) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if p.full, err = dec.DecodeUint64(); err == nil {
		err = dec.Decode(&p.data)
	}
	return
}

// --------------------------- Component of float32 ----------------------------

// OfFloat32 represents an array of components.
type OfFloat32 struct {
	sync.RWMutex
	typ  relfect.Type
	free []int
	page []pageOfFloat32
}

// ForFloat32 creates an array of components for the specific type.
func ForFloat32() *OfFloat32 {
	const cap = 128
	c := &OfFloat32{
		free: make([]int, 0, cap),
		page: make([]pageOfFloat32, 0, cap),
	}
	c.typ = relfect.TypeOf(c)
	return c
}

// Type returns the type of the component.
func (c *OfFloat32) Type() reflect.Type {
	return c.typ
}

// Add adds a component to the array. Returns the index in the array which
// can be used to remove the component from the array.
func (c *OfFloat32) Add(entity *ecs.Entity, v float32) {
	c.Lock()
	defer c.Unlock()

	if len(c.free) == 0 {
		pageAt := len(c.page)
		c.page = append(c.page, pageOfFloat32{})
		c.free = append(c.free, pageAt)
		c.attach(entity, pageAt, c.page[pageAt].Add(v))
		return
	}

	// find the free page and append
	last := len(c.free) - 1
	pageAt := c.free[last]
	offset := c.page[pageAt].Add(v)
	if c.page[pageAt].IsFull() {
		c.free = c.free[:last]
	}
	c.attach(entity, pageAt, offset)
}

// attach attaches the remove function to the entity.
func (c *OfFloat32) attach(entity *ecs.Entity, pageAt, offset int) {
	index := (64 * pageAt) + offset
	entity.Attach(func() {
		c.Lock()
		defer c.Unlock()
		pageAt, offset := index/64, index%64
		if c.page[pageAt].IsFull() {
			c.free = append(c.free, pageAt)
		}
		c.page[pageAt].Del(offset)
	})
}

// View iterates over the array but only acquires a read lock. Make sure you do
// not mutate the state during this iteration as the pointer is given merely for
// performance reasons.
func (c *OfFloat32) View(f func(*float32)) {
	c.RLock()
	defer c.RUnlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// Update ranges over the data in the slice and lets the user update it. This
// acquires a read-write lock and is safe to update concurrently.
func (c *OfFloat32) Update(f func(*float32)) {
	c.Lock()
	defer c.Unlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// EncodeMsgpack encodes the component in message pack format into the writer.
func (c *OfFloat32) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.Encode(c.free); err == nil {
		err = enc.Encode(c.page)
	}
	return
}

// DecodeMsgpack decodes the page from the reader in message pack format.
func (c *OfFloat32) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if err = dec.Decode(&c.free); err == nil {
		err = dec.Decode(&c.page)
	}
	return
}

// ---------------------------- Page of float32 -----------------------------

// Page represents a page for a particular type.
type pageOfFloat32 struct {
	full uint64
	data [64]float32
}

// Add adds an element to the page and returns the offset.
func (p *pageOfFloat32) Add(v float32) (index int) {
	if p.IsFull() {
		return -1
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) == 0 {
			p.full |= (1 << i)
			p.data[i] = v
			return i
		}
	}
	return -1
}

// Del deletes an element at an offset.
func (p *pageOfFloat32) Del(index int) {
	p.full &= uint64(^(1 << index))
}

// IsFull checks whether the page is full or not.
func (p *pageOfFloat32) IsFull() bool {
	return p.full == math.MaxUint64
}

// Range iterates over the page.
func (p *pageOfFloat32) Range(f func(*float32)) {
	if p.IsFull() {
		for i := 0; i < 64; i++ {
			f(&p.data[i])
		}
		return
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) > 0 {
			f(&p.data[i])
		}
	}
}

// Encode encodes the page in message pack format into the writer.
func (p *pageOfFloat32) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.EncodeUint64(p.full); err == nil {
		err = enc.Encode(p.data)
	}
	return
}

// Decode decodes the page from the reader in message pack format.
func (p *pageOfFloat32) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if p.full, err = dec.DecodeUint64(); err == nil {
		err = dec.Decode(&p.data)
	}
	return
}

// --------------------------- Component of float64 ----------------------------

// OfFloat64 represents an array of components.
type OfFloat64 struct {
	sync.RWMutex
	typ  relfect.Type
	free []int
	page []pageOfFloat64
}

// ForFloat64 creates an array of components for the specific type.
func ForFloat64() *OfFloat64 {
	const cap = 128
	c := &OfFloat64{
		free: make([]int, 0, cap),
		page: make([]pageOfFloat64, 0, cap),
	}
	c.typ = relfect.TypeOf(c)
	return c
}

// Type returns the type of the component.
func (c *OfFloat64) Type() reflect.Type {
	return c.typ
}

// Add adds a component to the array. Returns the index in the array which
// can be used to remove the component from the array.
func (c *OfFloat64) Add(entity *ecs.Entity, v float64) {
	c.Lock()
	defer c.Unlock()

	if len(c.free) == 0 {
		pageAt := len(c.page)
		c.page = append(c.page, pageOfFloat64{})
		c.free = append(c.free, pageAt)
		c.attach(entity, pageAt, c.page[pageAt].Add(v))
		return
	}

	// find the free page and append
	last := len(c.free) - 1
	pageAt := c.free[last]
	offset := c.page[pageAt].Add(v)
	if c.page[pageAt].IsFull() {
		c.free = c.free[:last]
	}
	c.attach(entity, pageAt, offset)
}

// attach attaches the remove function to the entity.
func (c *OfFloat64) attach(entity *ecs.Entity, pageAt, offset int) {
	index := (64 * pageAt) + offset
	entity.Attach(func() {
		c.Lock()
		defer c.Unlock()
		pageAt, offset := index/64, index%64
		if c.page[pageAt].IsFull() {
			c.free = append(c.free, pageAt)
		}
		c.page[pageAt].Del(offset)
	})
}

// View iterates over the array but only acquires a read lock. Make sure you do
// not mutate the state during this iteration as the pointer is given merely for
// performance reasons.
func (c *OfFloat64) View(f func(*float64)) {
	c.RLock()
	defer c.RUnlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// Update ranges over the data in the slice and lets the user update it. This
// acquires a read-write lock and is safe to update concurrently.
func (c *OfFloat64) Update(f func(*float64)) {
	c.Lock()
	defer c.Unlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// EncodeMsgpack encodes the component in message pack format into the writer.
func (c *OfFloat64) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.Encode(c.free); err == nil {
		err = enc.Encode(c.page)
	}
	return
}

// DecodeMsgpack decodes the page from the reader in message pack format.
func (c *OfFloat64) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if err = dec.Decode(&c.free); err == nil {
		err = dec.Decode(&c.page)
	}
	return
}

// ---------------------------- Page of float64 -----------------------------

// Page represents a page for a particular type.
type pageOfFloat64 struct {
	full uint64
	data [64]float64
}

// Add adds an element to the page and returns the offset.
func (p *pageOfFloat64) Add(v float64) (index int) {
	if p.IsFull() {
		return -1
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) == 0 {
			p.full |= (1 << i)
			p.data[i] = v
			return i
		}
	}
	return -1
}

// Del deletes an element at an offset.
func (p *pageOfFloat64) Del(index int) {
	p.full &= uint64(^(1 << index))
}

// IsFull checks whether the page is full or not.
func (p *pageOfFloat64) IsFull() bool {
	return p.full == math.MaxUint64
}

// Range iterates over the page.
func (p *pageOfFloat64) Range(f func(*float64)) {
	if p.IsFull() {
		for i := 0; i < 64; i++ {
			f(&p.data[i])
		}
		return
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) > 0 {
			f(&p.data[i])
		}
	}
}

// Encode encodes the page in message pack format into the writer.
func (p *pageOfFloat64) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.EncodeUint64(p.full); err == nil {
		err = enc.Encode(p.data)
	}
	return
}

// Decode decodes the page from the reader in message pack format.
func (p *pageOfFloat64) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if p.full, err = dec.DecodeUint64(); err == nil {
		err = dec.Decode(&p.data)
	}
	return
}

// --------------------------- Component of int16 ----------------------------

// OfInt16 represents an array of components.
type OfInt16 struct {
	sync.RWMutex
	typ  relfect.Type
	free []int
	page []pageOfInt16
}

// ForInt16 creates an array of components for the specific type.
func ForInt16() *OfInt16 {
	const cap = 128
	c := &OfInt16{
		free: make([]int, 0, cap),
		page: make([]pageOfInt16, 0, cap),
	}
	c.typ = relfect.TypeOf(c)
	return c
}

// Type returns the type of the component.
func (c *OfInt16) Type() reflect.Type {
	return c.typ
}

// Add adds a component to the array. Returns the index in the array which
// can be used to remove the component from the array.
func (c *OfInt16) Add(entity *ecs.Entity, v int16) {
	c.Lock()
	defer c.Unlock()

	if len(c.free) == 0 {
		pageAt := len(c.page)
		c.page = append(c.page, pageOfInt16{})
		c.free = append(c.free, pageAt)
		c.attach(entity, pageAt, c.page[pageAt].Add(v))
		return
	}

	// find the free page and append
	last := len(c.free) - 1
	pageAt := c.free[last]
	offset := c.page[pageAt].Add(v)
	if c.page[pageAt].IsFull() {
		c.free = c.free[:last]
	}
	c.attach(entity, pageAt, offset)
}

// attach attaches the remove function to the entity.
func (c *OfInt16) attach(entity *ecs.Entity, pageAt, offset int) {
	index := (64 * pageAt) + offset
	entity.Attach(func() {
		c.Lock()
		defer c.Unlock()
		pageAt, offset := index/64, index%64
		if c.page[pageAt].IsFull() {
			c.free = append(c.free, pageAt)
		}
		c.page[pageAt].Del(offset)
	})
}

// View iterates over the array but only acquires a read lock. Make sure you do
// not mutate the state during this iteration as the pointer is given merely for
// performance reasons.
func (c *OfInt16) View(f func(*int16)) {
	c.RLock()
	defer c.RUnlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// Update ranges over the data in the slice and lets the user update it. This
// acquires a read-write lock and is safe to update concurrently.
func (c *OfInt16) Update(f func(*int16)) {
	c.Lock()
	defer c.Unlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// EncodeMsgpack encodes the component in message pack format into the writer.
func (c *OfInt16) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.Encode(c.free); err == nil {
		err = enc.Encode(c.page)
	}
	return
}

// DecodeMsgpack decodes the page from the reader in message pack format.
func (c *OfInt16) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if err = dec.Decode(&c.free); err == nil {
		err = dec.Decode(&c.page)
	}
	return
}

// ---------------------------- Page of int16 -----------------------------

// Page represents a page for a particular type.
type pageOfInt16 struct {
	full uint64
	data [64]int16
}

// Add adds an element to the page and returns the offset.
func (p *pageOfInt16) Add(v int16) (index int) {
	if p.IsFull() {
		return -1
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) == 0 {
			p.full |= (1 << i)
			p.data[i] = v
			return i
		}
	}
	return -1
}

// Del deletes an element at an offset.
func (p *pageOfInt16) Del(index int) {
	p.full &= uint64(^(1 << index))
}

// IsFull checks whether the page is full or not.
func (p *pageOfInt16) IsFull() bool {
	return p.full == math.MaxUint64
}

// Range iterates over the page.
func (p *pageOfInt16) Range(f func(*int16)) {
	if p.IsFull() {
		for i := 0; i < 64; i++ {
			f(&p.data[i])
		}
		return
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) > 0 {
			f(&p.data[i])
		}
	}
}

// Encode encodes the page in message pack format into the writer.
func (p *pageOfInt16) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.EncodeUint64(p.full); err == nil {
		err = enc.Encode(p.data)
	}
	return
}

// Decode decodes the page from the reader in message pack format.
func (p *pageOfInt16) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if p.full, err = dec.DecodeUint64(); err == nil {
		err = dec.Decode(&p.data)
	}
	return
}

// --------------------------- Component of int32 ----------------------------

// OfInt32 represents an array of components.
type OfInt32 struct {
	sync.RWMutex
	typ  relfect.Type
	free []int
	page []pageOfInt32
}

// ForInt32 creates an array of components for the specific type.
func ForInt32() *OfInt32 {
	const cap = 128
	c := &OfInt32{
		free: make([]int, 0, cap),
		page: make([]pageOfInt32, 0, cap),
	}
	c.typ = relfect.TypeOf(c)
	return c
}

// Type returns the type of the component.
func (c *OfInt32) Type() reflect.Type {
	return c.typ
}

// Add adds a component to the array. Returns the index in the array which
// can be used to remove the component from the array.
func (c *OfInt32) Add(entity *ecs.Entity, v int32) {
	c.Lock()
	defer c.Unlock()

	if len(c.free) == 0 {
		pageAt := len(c.page)
		c.page = append(c.page, pageOfInt32{})
		c.free = append(c.free, pageAt)
		c.attach(entity, pageAt, c.page[pageAt].Add(v))
		return
	}

	// find the free page and append
	last := len(c.free) - 1
	pageAt := c.free[last]
	offset := c.page[pageAt].Add(v)
	if c.page[pageAt].IsFull() {
		c.free = c.free[:last]
	}
	c.attach(entity, pageAt, offset)
}

// attach attaches the remove function to the entity.
func (c *OfInt32) attach(entity *ecs.Entity, pageAt, offset int) {
	index := (64 * pageAt) + offset
	entity.Attach(func() {
		c.Lock()
		defer c.Unlock()
		pageAt, offset := index/64, index%64
		if c.page[pageAt].IsFull() {
			c.free = append(c.free, pageAt)
		}
		c.page[pageAt].Del(offset)
	})
}

// View iterates over the array but only acquires a read lock. Make sure you do
// not mutate the state during this iteration as the pointer is given merely for
// performance reasons.
func (c *OfInt32) View(f func(*int32)) {
	c.RLock()
	defer c.RUnlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// Update ranges over the data in the slice and lets the user update it. This
// acquires a read-write lock and is safe to update concurrently.
func (c *OfInt32) Update(f func(*int32)) {
	c.Lock()
	defer c.Unlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// EncodeMsgpack encodes the component in message pack format into the writer.
func (c *OfInt32) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.Encode(c.free); err == nil {
		err = enc.Encode(c.page)
	}
	return
}

// DecodeMsgpack decodes the page from the reader in message pack format.
func (c *OfInt32) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if err = dec.Decode(&c.free); err == nil {
		err = dec.Decode(&c.page)
	}
	return
}

// ---------------------------- Page of int32 -----------------------------

// Page represents a page for a particular type.
type pageOfInt32 struct {
	full uint64
	data [64]int32
}

// Add adds an element to the page and returns the offset.
func (p *pageOfInt32) Add(v int32) (index int) {
	if p.IsFull() {
		return -1
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) == 0 {
			p.full |= (1 << i)
			p.data[i] = v
			return i
		}
	}
	return -1
}

// Del deletes an element at an offset.
func (p *pageOfInt32) Del(index int) {
	p.full &= uint64(^(1 << index))
}

// IsFull checks whether the page is full or not.
func (p *pageOfInt32) IsFull() bool {
	return p.full == math.MaxUint64
}

// Range iterates over the page.
func (p *pageOfInt32) Range(f func(*int32)) {
	if p.IsFull() {
		for i := 0; i < 64; i++ {
			f(&p.data[i])
		}
		return
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) > 0 {
			f(&p.data[i])
		}
	}
}

// Encode encodes the page in message pack format into the writer.
func (p *pageOfInt32) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.EncodeUint64(p.full); err == nil {
		err = enc.Encode(p.data)
	}
	return
}

// Decode decodes the page from the reader in message pack format.
func (p *pageOfInt32) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if p.full, err = dec.DecodeUint64(); err == nil {
		err = dec.Decode(&p.data)
	}
	return
}

// --------------------------- Component of int64 ----------------------------

// OfInt64 represents an array of components.
type OfInt64 struct {
	sync.RWMutex
	typ  relfect.Type
	free []int
	page []pageOfInt64
}

// ForInt64 creates an array of components for the specific type.
func ForInt64() *OfInt64 {
	const cap = 128
	c := &OfInt64{
		free: make([]int, 0, cap),
		page: make([]pageOfInt64, 0, cap),
	}
	c.typ = relfect.TypeOf(c)
	return c
}

// Type returns the type of the component.
func (c *OfInt64) Type() reflect.Type {
	return c.typ
}

// Add adds a component to the array. Returns the index in the array which
// can be used to remove the component from the array.
func (c *OfInt64) Add(entity *ecs.Entity, v int64) {
	c.Lock()
	defer c.Unlock()

	if len(c.free) == 0 {
		pageAt := len(c.page)
		c.page = append(c.page, pageOfInt64{})
		c.free = append(c.free, pageAt)
		c.attach(entity, pageAt, c.page[pageAt].Add(v))
		return
	}

	// find the free page and append
	last := len(c.free) - 1
	pageAt := c.free[last]
	offset := c.page[pageAt].Add(v)
	if c.page[pageAt].IsFull() {
		c.free = c.free[:last]
	}
	c.attach(entity, pageAt, offset)
}

// attach attaches the remove function to the entity.
func (c *OfInt64) attach(entity *ecs.Entity, pageAt, offset int) {
	index := (64 * pageAt) + offset
	entity.Attach(func() {
		c.Lock()
		defer c.Unlock()
		pageAt, offset := index/64, index%64
		if c.page[pageAt].IsFull() {
			c.free = append(c.free, pageAt)
		}
		c.page[pageAt].Del(offset)
	})
}

// View iterates over the array but only acquires a read lock. Make sure you do
// not mutate the state during this iteration as the pointer is given merely for
// performance reasons.
func (c *OfInt64) View(f func(*int64)) {
	c.RLock()
	defer c.RUnlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// Update ranges over the data in the slice and lets the user update it. This
// acquires a read-write lock and is safe to update concurrently.
func (c *OfInt64) Update(f func(*int64)) {
	c.Lock()
	defer c.Unlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// EncodeMsgpack encodes the component in message pack format into the writer.
func (c *OfInt64) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.Encode(c.free); err == nil {
		err = enc.Encode(c.page)
	}
	return
}

// DecodeMsgpack decodes the page from the reader in message pack format.
func (c *OfInt64) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if err = dec.Decode(&c.free); err == nil {
		err = dec.Decode(&c.page)
	}
	return
}

// ---------------------------- Page of int64 -----------------------------

// Page represents a page for a particular type.
type pageOfInt64 struct {
	full uint64
	data [64]int64
}

// Add adds an element to the page and returns the offset.
func (p *pageOfInt64) Add(v int64) (index int) {
	if p.IsFull() {
		return -1
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) == 0 {
			p.full |= (1 << i)
			p.data[i] = v
			return i
		}
	}
	return -1
}

// Del deletes an element at an offset.
func (p *pageOfInt64) Del(index int) {
	p.full &= uint64(^(1 << index))
}

// IsFull checks whether the page is full or not.
func (p *pageOfInt64) IsFull() bool {
	return p.full == math.MaxUint64
}

// Range iterates over the page.
func (p *pageOfInt64) Range(f func(*int64)) {
	if p.IsFull() {
		for i := 0; i < 64; i++ {
			f(&p.data[i])
		}
		return
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) > 0 {
			f(&p.data[i])
		}
	}
}

// Encode encodes the page in message pack format into the writer.
func (p *pageOfInt64) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.EncodeUint64(p.full); err == nil {
		err = enc.Encode(p.data)
	}
	return
}

// Decode decodes the page from the reader in message pack format.
func (p *pageOfInt64) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if p.full, err = dec.DecodeUint64(); err == nil {
		err = dec.Decode(&p.data)
	}
	return
}

// --------------------------- Component of uint16 ----------------------------

// OfUint16 represents an array of components.
type OfUint16 struct {
	sync.RWMutex
	typ  relfect.Type
	free []int
	page []pageOfUint16
}

// ForUint16 creates an array of components for the specific type.
func ForUint16() *OfUint16 {
	const cap = 128
	c := &OfUint16{
		free: make([]int, 0, cap),
		page: make([]pageOfUint16, 0, cap),
	}
	c.typ = relfect.TypeOf(c)
	return c
}

// Type returns the type of the component.
func (c *OfUint16) Type() reflect.Type {
	return c.typ
}

// Add adds a component to the array. Returns the index in the array which
// can be used to remove the component from the array.
func (c *OfUint16) Add(entity *ecs.Entity, v uint16) {
	c.Lock()
	defer c.Unlock()

	if len(c.free) == 0 {
		pageAt := len(c.page)
		c.page = append(c.page, pageOfUint16{})
		c.free = append(c.free, pageAt)
		c.attach(entity, pageAt, c.page[pageAt].Add(v))
		return
	}

	// find the free page and append
	last := len(c.free) - 1
	pageAt := c.free[last]
	offset := c.page[pageAt].Add(v)
	if c.page[pageAt].IsFull() {
		c.free = c.free[:last]
	}
	c.attach(entity, pageAt, offset)
}

// attach attaches the remove function to the entity.
func (c *OfUint16) attach(entity *ecs.Entity, pageAt, offset int) {
	index := (64 * pageAt) + offset
	entity.Attach(func() {
		c.Lock()
		defer c.Unlock()
		pageAt, offset := index/64, index%64
		if c.page[pageAt].IsFull() {
			c.free = append(c.free, pageAt)
		}
		c.page[pageAt].Del(offset)
	})
}

// View iterates over the array but only acquires a read lock. Make sure you do
// not mutate the state during this iteration as the pointer is given merely for
// performance reasons.
func (c *OfUint16) View(f func(*uint16)) {
	c.RLock()
	defer c.RUnlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// Update ranges over the data in the slice and lets the user update it. This
// acquires a read-write lock and is safe to update concurrently.
func (c *OfUint16) Update(f func(*uint16)) {
	c.Lock()
	defer c.Unlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// EncodeMsgpack encodes the component in message pack format into the writer.
func (c *OfUint16) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.Encode(c.free); err == nil {
		err = enc.Encode(c.page)
	}
	return
}

// DecodeMsgpack decodes the page from the reader in message pack format.
func (c *OfUint16) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if err = dec.Decode(&c.free); err == nil {
		err = dec.Decode(&c.page)
	}
	return
}

// ---------------------------- Page of uint16 -----------------------------

// Page represents a page for a particular type.
type pageOfUint16 struct {
	full uint64
	data [64]uint16
}

// Add adds an element to the page and returns the offset.
func (p *pageOfUint16) Add(v uint16) (index int) {
	if p.IsFull() {
		return -1
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) == 0 {
			p.full |= (1 << i)
			p.data[i] = v
			return i
		}
	}
	return -1
}

// Del deletes an element at an offset.
func (p *pageOfUint16) Del(index int) {
	p.full &= uint64(^(1 << index))
}

// IsFull checks whether the page is full or not.
func (p *pageOfUint16) IsFull() bool {
	return p.full == math.MaxUint64
}

// Range iterates over the page.
func (p *pageOfUint16) Range(f func(*uint16)) {
	if p.IsFull() {
		for i := 0; i < 64; i++ {
			f(&p.data[i])
		}
		return
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) > 0 {
			f(&p.data[i])
		}
	}
}

// Encode encodes the page in message pack format into the writer.
func (p *pageOfUint16) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.EncodeUint64(p.full); err == nil {
		err = enc.Encode(p.data)
	}
	return
}

// Decode decodes the page from the reader in message pack format.
func (p *pageOfUint16) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if p.full, err = dec.DecodeUint64(); err == nil {
		err = dec.Decode(&p.data)
	}
	return
}

// --------------------------- Component of uint32 ----------------------------

// OfUint32 represents an array of components.
type OfUint32 struct {
	sync.RWMutex
	typ  relfect.Type
	free []int
	page []pageOfUint32
}

// ForUint32 creates an array of components for the specific type.
func ForUint32() *OfUint32 {
	const cap = 128
	c := &OfUint32{
		free: make([]int, 0, cap),
		page: make([]pageOfUint32, 0, cap),
	}
	c.typ = relfect.TypeOf(c)
	return c
}

// Type returns the type of the component.
func (c *OfUint32) Type() reflect.Type {
	return c.typ
}

// Add adds a component to the array. Returns the index in the array which
// can be used to remove the component from the array.
func (c *OfUint32) Add(entity *ecs.Entity, v uint32) {
	c.Lock()
	defer c.Unlock()

	if len(c.free) == 0 {
		pageAt := len(c.page)
		c.page = append(c.page, pageOfUint32{})
		c.free = append(c.free, pageAt)
		c.attach(entity, pageAt, c.page[pageAt].Add(v))
		return
	}

	// find the free page and append
	last := len(c.free) - 1
	pageAt := c.free[last]
	offset := c.page[pageAt].Add(v)
	if c.page[pageAt].IsFull() {
		c.free = c.free[:last]
	}
	c.attach(entity, pageAt, offset)
}

// attach attaches the remove function to the entity.
func (c *OfUint32) attach(entity *ecs.Entity, pageAt, offset int) {
	index := (64 * pageAt) + offset
	entity.Attach(func() {
		c.Lock()
		defer c.Unlock()
		pageAt, offset := index/64, index%64
		if c.page[pageAt].IsFull() {
			c.free = append(c.free, pageAt)
		}
		c.page[pageAt].Del(offset)
	})
}

// View iterates over the array but only acquires a read lock. Make sure you do
// not mutate the state during this iteration as the pointer is given merely for
// performance reasons.
func (c *OfUint32) View(f func(*uint32)) {
	c.RLock()
	defer c.RUnlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// Update ranges over the data in the slice and lets the user update it. This
// acquires a read-write lock and is safe to update concurrently.
func (c *OfUint32) Update(f func(*uint32)) {
	c.Lock()
	defer c.Unlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// EncodeMsgpack encodes the component in message pack format into the writer.
func (c *OfUint32) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.Encode(c.free); err == nil {
		err = enc.Encode(c.page)
	}
	return
}

// DecodeMsgpack decodes the page from the reader in message pack format.
func (c *OfUint32) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if err = dec.Decode(&c.free); err == nil {
		err = dec.Decode(&c.page)
	}
	return
}

// ---------------------------- Page of uint32 -----------------------------

// Page represents a page for a particular type.
type pageOfUint32 struct {
	full uint64
	data [64]uint32
}

// Add adds an element to the page and returns the offset.
func (p *pageOfUint32) Add(v uint32) (index int) {
	if p.IsFull() {
		return -1
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) == 0 {
			p.full |= (1 << i)
			p.data[i] = v
			return i
		}
	}
	return -1
}

// Del deletes an element at an offset.
func (p *pageOfUint32) Del(index int) {
	p.full &= uint64(^(1 << index))
}

// IsFull checks whether the page is full or not.
func (p *pageOfUint32) IsFull() bool {
	return p.full == math.MaxUint64
}

// Range iterates over the page.
func (p *pageOfUint32) Range(f func(*uint32)) {
	if p.IsFull() {
		for i := 0; i < 64; i++ {
			f(&p.data[i])
		}
		return
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) > 0 {
			f(&p.data[i])
		}
	}
}

// Encode encodes the page in message pack format into the writer.
func (p *pageOfUint32) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.EncodeUint64(p.full); err == nil {
		err = enc.Encode(p.data)
	}
	return
}

// Decode decodes the page from the reader in message pack format.
func (p *pageOfUint32) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if p.full, err = dec.DecodeUint64(); err == nil {
		err = dec.Decode(&p.data)
	}
	return
}

// --------------------------- Component of uint64 ----------------------------

// OfUint64 represents an array of components.
type OfUint64 struct {
	sync.RWMutex
	typ  relfect.Type
	free []int
	page []pageOfUint64
}

// ForUint64 creates an array of components for the specific type.
func ForUint64() *OfUint64 {
	const cap = 128
	c := &OfUint64{
		free: make([]int, 0, cap),
		page: make([]pageOfUint64, 0, cap),
	}
	c.typ = relfect.TypeOf(c)
	return c
}

// Type returns the type of the component.
func (c *OfUint64) Type() reflect.Type {
	return c.typ
}

// Add adds a component to the array. Returns the index in the array which
// can be used to remove the component from the array.
func (c *OfUint64) Add(entity *ecs.Entity, v uint64) {
	c.Lock()
	defer c.Unlock()

	if len(c.free) == 0 {
		pageAt := len(c.page)
		c.page = append(c.page, pageOfUint64{})
		c.free = append(c.free, pageAt)
		c.attach(entity, pageAt, c.page[pageAt].Add(v))
		return
	}

	// find the free page and append
	last := len(c.free) - 1
	pageAt := c.free[last]
	offset := c.page[pageAt].Add(v)
	if c.page[pageAt].IsFull() {
		c.free = c.free[:last]
	}
	c.attach(entity, pageAt, offset)
}

// attach attaches the remove function to the entity.
func (c *OfUint64) attach(entity *ecs.Entity, pageAt, offset int) {
	index := (64 * pageAt) + offset
	entity.Attach(func() {
		c.Lock()
		defer c.Unlock()
		pageAt, offset := index/64, index%64
		if c.page[pageAt].IsFull() {
			c.free = append(c.free, pageAt)
		}
		c.page[pageAt].Del(offset)
	})
}

// View iterates over the array but only acquires a read lock. Make sure you do
// not mutate the state during this iteration as the pointer is given merely for
// performance reasons.
func (c *OfUint64) View(f func(*uint64)) {
	c.RLock()
	defer c.RUnlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// Update ranges over the data in the slice and lets the user update it. This
// acquires a read-write lock and is safe to update concurrently.
func (c *OfUint64) Update(f func(*uint64)) {
	c.Lock()
	defer c.Unlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// EncodeMsgpack encodes the component in message pack format into the writer.
func (c *OfUint64) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.Encode(c.free); err == nil {
		err = enc.Encode(c.page)
	}
	return
}

// DecodeMsgpack decodes the page from the reader in message pack format.
func (c *OfUint64) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if err = dec.Decode(&c.free); err == nil {
		err = dec.Decode(&c.page)
	}
	return
}

// ---------------------------- Page of uint64 -----------------------------

// Page represents a page for a particular type.
type pageOfUint64 struct {
	full uint64
	data [64]uint64
}

// Add adds an element to the page and returns the offset.
func (p *pageOfUint64) Add(v uint64) (index int) {
	if p.IsFull() {
		return -1
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) == 0 {
			p.full |= (1 << i)
			p.data[i] = v
			return i
		}
	}
	return -1
}

// Del deletes an element at an offset.
func (p *pageOfUint64) Del(index int) {
	p.full &= uint64(^(1 << index))
}

// IsFull checks whether the page is full or not.
func (p *pageOfUint64) IsFull() bool {
	return p.full == math.MaxUint64
}

// Range iterates over the page.
func (p *pageOfUint64) Range(f func(*uint64)) {
	if p.IsFull() {
		for i := 0; i < 64; i++ {
			f(&p.data[i])
		}
		return
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) > 0 {
			f(&p.data[i])
		}
	}
}

// Encode encodes the page in message pack format into the writer.
func (p *pageOfUint64) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.EncodeUint64(p.full); err == nil {
		err = enc.Encode(p.data)
	}
	return
}

// Decode decodes the page from the reader in message pack format.
func (p *pageOfUint64) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if p.full, err = dec.DecodeUint64(); err == nil {
		err = dec.Decode(&p.data)
	}
	return
}

// --------------------------- Component of Vector2 ----------------------------

// OfVector2 represents an array of components.
type OfVector2 struct {
	sync.RWMutex
	typ  relfect.Type
	free []int
	page []pageOfVector2
}

// ForVector2 creates an array of components for the specific type.
func ForVector2() *OfVector2 {
	const cap = 128
	c := &OfVector2{
		free: make([]int, 0, cap),
		page: make([]pageOfVector2, 0, cap),
	}
	c.typ = relfect.TypeOf(c)
	return c
}

// Type returns the type of the component.
func (c *OfVector2) Type() reflect.Type {
	return c.typ
}

// Add adds a component to the array. Returns the index in the array which
// can be used to remove the component from the array.
func (c *OfVector2) Add(entity *ecs.Entity, v Vector2) {
	c.Lock()
	defer c.Unlock()

	if len(c.free) == 0 {
		pageAt := len(c.page)
		c.page = append(c.page, pageOfVector2{})
		c.free = append(c.free, pageAt)
		c.attach(entity, pageAt, c.page[pageAt].Add(v))
		return
	}

	// find the free page and append
	last := len(c.free) - 1
	pageAt := c.free[last]
	offset := c.page[pageAt].Add(v)
	if c.page[pageAt].IsFull() {
		c.free = c.free[:last]
	}
	c.attach(entity, pageAt, offset)
}

// attach attaches the remove function to the entity.
func (c *OfVector2) attach(entity *ecs.Entity, pageAt, offset int) {
	index := (64 * pageAt) + offset
	entity.Attach(func() {
		c.Lock()
		defer c.Unlock()
		pageAt, offset := index/64, index%64
		if c.page[pageAt].IsFull() {
			c.free = append(c.free, pageAt)
		}
		c.page[pageAt].Del(offset)
	})
}

// View iterates over the array but only acquires a read lock. Make sure you do
// not mutate the state during this iteration as the pointer is given merely for
// performance reasons.
func (c *OfVector2) View(f func(*Vector2)) {
	c.RLock()
	defer c.RUnlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// Update ranges over the data in the slice and lets the user update it. This
// acquires a read-write lock and is safe to update concurrently.
func (c *OfVector2) Update(f func(*Vector2)) {
	c.Lock()
	defer c.Unlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// EncodeMsgpack encodes the component in message pack format into the writer.
func (c *OfVector2) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.Encode(c.free); err == nil {
		err = enc.Encode(c.page)
	}
	return
}

// DecodeMsgpack decodes the page from the reader in message pack format.
func (c *OfVector2) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if err = dec.Decode(&c.free); err == nil {
		err = dec.Decode(&c.page)
	}
	return
}

// ---------------------------- Page of Vector2 -----------------------------

// Page represents a page for a particular type.
type pageOfVector2 struct {
	full uint64
	data [64]Vector2
}

// Add adds an element to the page and returns the offset.
func (p *pageOfVector2) Add(v Vector2) (index int) {
	if p.IsFull() {
		return -1
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) == 0 {
			p.full |= (1 << i)
			p.data[i] = v
			return i
		}
	}
	return -1
}

// Del deletes an element at an offset.
func (p *pageOfVector2) Del(index int) {
	p.full &= uint64(^(1 << index))
}

// IsFull checks whether the page is full or not.
func (p *pageOfVector2) IsFull() bool {
	return p.full == math.MaxUint64
}

// Range iterates over the page.
func (p *pageOfVector2) Range(f func(*Vector2)) {
	if p.IsFull() {
		for i := 0; i < 64; i++ {
			f(&p.data[i])
		}
		return
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) > 0 {
			f(&p.data[i])
		}
	}
}

// Encode encodes the page in message pack format into the writer.
func (p *pageOfVector2) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.EncodeUint64(p.full); err == nil {
		err = enc.Encode(p.data)
	}
	return
}

// Decode decodes the page from the reader in message pack format.
func (p *pageOfVector2) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if p.full, err = dec.DecodeUint64(); err == nil {
		err = dec.Decode(&p.data)
	}
	return
}

// --------------------------- Component of Vector3 ----------------------------

// OfVector3 represents an array of components.
type OfVector3 struct {
	sync.RWMutex
	typ  relfect.Type
	free []int
	page []pageOfVector3
}

// ForVector3 creates an array of components for the specific type.
func ForVector3() *OfVector3 {
	const cap = 128
	c := &OfVector3{
		free: make([]int, 0, cap),
		page: make([]pageOfVector3, 0, cap),
	}
	c.typ = relfect.TypeOf(c)
	return c
}

// Type returns the type of the component.
func (c *OfVector3) Type() reflect.Type {
	return c.typ
}

// Add adds a component to the array. Returns the index in the array which
// can be used to remove the component from the array.
func (c *OfVector3) Add(entity *ecs.Entity, v Vector3) {
	c.Lock()
	defer c.Unlock()

	if len(c.free) == 0 {
		pageAt := len(c.page)
		c.page = append(c.page, pageOfVector3{})
		c.free = append(c.free, pageAt)
		c.attach(entity, pageAt, c.page[pageAt].Add(v))
		return
	}

	// find the free page and append
	last := len(c.free) - 1
	pageAt := c.free[last]
	offset := c.page[pageAt].Add(v)
	if c.page[pageAt].IsFull() {
		c.free = c.free[:last]
	}
	c.attach(entity, pageAt, offset)
}

// attach attaches the remove function to the entity.
func (c *OfVector3) attach(entity *ecs.Entity, pageAt, offset int) {
	index := (64 * pageAt) + offset
	entity.Attach(func() {
		c.Lock()
		defer c.Unlock()
		pageAt, offset := index/64, index%64
		if c.page[pageAt].IsFull() {
			c.free = append(c.free, pageAt)
		}
		c.page[pageAt].Del(offset)
	})
}

// View iterates over the array but only acquires a read lock. Make sure you do
// not mutate the state during this iteration as the pointer is given merely for
// performance reasons.
func (c *OfVector3) View(f func(*Vector3)) {
	c.RLock()
	defer c.RUnlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// Update ranges over the data in the slice and lets the user update it. This
// acquires a read-write lock and is safe to update concurrently.
func (c *OfVector3) Update(f func(*Vector3)) {
	c.Lock()
	defer c.Unlock()
	for i := 0; i < len(c.page); i++ {
		c.page[i].Range(f)
	}
}

// EncodeMsgpack encodes the component in message pack format into the writer.
func (c *OfVector3) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.Encode(c.free); err == nil {
		err = enc.Encode(c.page)
	}
	return
}

// DecodeMsgpack decodes the page from the reader in message pack format.
func (c *OfVector3) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if err = dec.Decode(&c.free); err == nil {
		err = dec.Decode(&c.page)
	}
	return
}

// ---------------------------- Page of Vector3 -----------------------------

// Page represents a page for a particular type.
type pageOfVector3 struct {
	full uint64
	data [64]Vector3
}

// Add adds an element to the page and returns the offset.
func (p *pageOfVector3) Add(v Vector3) (index int) {
	if p.IsFull() {
		return -1
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) == 0 {
			p.full |= (1 << i)
			p.data[i] = v
			return i
		}
	}
	return -1
}

// Del deletes an element at an offset.
func (p *pageOfVector3) Del(index int) {
	p.full &= uint64(^(1 << index))
}

// IsFull checks whether the page is full or not.
func (p *pageOfVector3) IsFull() bool {
	return p.full == math.MaxUint64
}

// Range iterates over the page.
func (p *pageOfVector3) Range(f func(*Vector3)) {
	if p.IsFull() {
		for i := 0; i < 64; i++ {
			f(&p.data[i])
		}
		return
	}

	for i := 0; i < 64; i++ {
		if (p.full & (1 << i)) > 0 {
			f(&p.data[i])
		}
	}
}

// Encode encodes the page in message pack format into the writer.
func (p *pageOfVector3) EncodeMsgpack(enc *msgpack.Encoder) (err error) {
	if err = enc.EncodeUint64(p.full); err == nil {
		err = enc.Encode(p.data)
	}
	return
}

// Decode decodes the page from the reader in message pack format.
func (p *pageOfVector3) DecodeMsgpack(dec *msgpack.Decoder) (err error) {
	if p.full, err = dec.DecodeUint64(); err == nil {
		err = dec.Decode(&p.data)
	}
	return
}
